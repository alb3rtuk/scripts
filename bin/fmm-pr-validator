#!/usr/bin/env ruby

require 'blufin-lib'
require 'json'
require 'mechanize'
require 'open-uri'
require 'pry'

PATH_FMM = '/tmp/FMM'

# Clear the screen.
system('clear')

# Display ASCII banner.
puts <<TEMPLATE

    ███████╗███╗   ███╗███╗   ███╗    ██████╗ ██████╗     ██╗   ██╗ █████╗ ██╗     ██╗██████╗  █████╗ ████████╗ ██████╗ ██████╗
    ██╔════╝████╗ ████║████╗ ████║    ██╔══██╗██╔══██╗    ██║   ██║██╔══██╗██║     ██║██╔══██╗██╔══██╗╚══██╔══╝██╔═══██╗██╔══██╗
    █████╗  ██╔████╔██║██╔████╔██║    ██████╔╝██████╔╝    ██║   ██║███████║██║     ██║██║  ██║███████║   ██║   ██║   ██║██████╔╝
    ██╔══╝  ██║╚██╔╝██║██║╚██╔╝██║    ██╔═══╝ ██╔══██╗    ╚██╗ ██╔╝██╔══██║██║     ██║██║  ██║██╔══██║   ██║   ██║   ██║██╔══██╗
    ██║     ██║ ╚═╝ ██║██║ ╚═╝ ██║    ██║     ██║  ██║     ╚████╔╝ ██║  ██║███████╗██║██████╔╝██║  ██║   ██║   ╚██████╔╝██║  ██║
    ╚═╝     ╚═╝     ╚═╝╚═╝     ╚═╝    ╚═╝     ╚═╝  ╚═╝      ╚═══╝  ╚═╝  ╚═╝╚══════╝╚═╝╚═════╝ ╚═╝  ╚═╝   ╚═╝    ╚═════╝ ╚═╝  ╚═╝
\x1B[0m
TEMPLATE

@agent       = Mechanize.new
@login_page  = nil
@pr_page     = nil
@git_fetch_p = false
@git_pull    = []

# Get secrets.
base_path    = File.dirname(File.expand_path(__FILE__))
file_content = []
Blufin::Files::read_file("#{base_path}/../.secrets/.secrets.json").each { |line| file_content << line.gsub("\n", '').strip }
file_content_joined = file_content.join(' ')
@secrets            = JSON.parse(file_content_joined)

# Checks if FMM is checked out in the /tmp folder.
# @return void
def validate_merge(source, target)
    unless Blufin::Files::path_exists(PATH_FMM)
        Blufin::Terminal::execute_proc('Checking out FMM (into /tmp)', Proc.new {
            `cd /tmp && git clone #{@secrets['github']['repos']['fmm_ssh']} FMM`
        }, hide_progress: true)
    end
    # Only run once.
    unless @git_fetch_p
        raise RuntimeError, 'Unable to: git fetch -p' unless Blufin::Terminal::execute('git fetch -p', '/tmp/FMM', verbose: false, display_error: false)
        @git_fetch_p = true
    end
    raise RuntimeError, 'Unable to: git reset --hard HEAD' unless Blufin::Terminal::execute('git reset --hard HEAD', '/tmp/FMM', verbose: false, display_error: false)[0]
    # Only pull once.
    unless @git_pull.include?(target)
        raise RuntimeError, "Unable to: git checkout #{target}" unless Blufin::Terminal::execute("git checkout #{target}", '/tmp/FMM', verbose: false, display_error: false, ignore_error: true)
        raise RuntimeError, "Unable to: git pull (on #{target})" unless Blufin::Terminal::execute('git pull', '/tmp/FMM', text: "git pull #{target}", verbose: false, display_error: false)
        @git_pull << target
    end
    raise RuntimeError, "Unable to: git checkout #{source}" unless Blufin::Terminal::execute("git checkout #{source}", '/tmp/FMM', verbose: false, display_error: false, ignore_error: true)
    raise RuntimeError, "Unable to: git pull (on #{source})" unless Blufin::Terminal::execute('git pull', '/tmp/FMM', text: "git pull #{source}", verbose: false, display_error: false)
    res = Blufin::Terminal::execute("git merge #{target}", '/tmp/FMM', text: "Merge: #{target} \xe2\x86\x92 #{source}", verbose: false, display_error: false)
    # If we have a merge conflict!
    if res[0]
        true
    else
        raise RuntimeError, 'Unable to: git reset --hard HEAD' unless Blufin::Terminal::execute('git reset --hard HEAD', '/tmp/FMM', verbose: false, display_error: false)[0]
        false
    end
end

Blufin::Terminal::execute_proc('Navigating to GitHub', Proc.new {
    @login_page = @agent.get(@secrets['github']['login_uri'])
}, hide_progress: false)

Blufin::Terminal::execute_proc('Logging into GitHub', Proc.new {
    login_form                                        = @login_page.form
    login_form.field_with(:id => 'login_field').value = @secrets['github']['user']
    login_form.field_with(:id => 'password').value    = @secrets['github']['pass']
    login_form.submit
}, hide_progress: false)

Blufin::Terminal::execute_proc("Navigating to Pull Requests: #{@secrets['github']['repos']['fmm_prs']}", Proc.new {
    @pr_page = @agent.get(@secrets['github']['repos']['fmm_prs'])
}, hide_progress: false)

@pr_page.links_with(:id => /issue_/).each do |link|
    pr_inner_page = @agent.get(link.uri)
    author        = pr_inner_page.at('a.author.css-truncate-target').to_s.strip.gsub(/^<a.*">/, '').gsub(/<\/a>$/, '')
    target        = pr_inner_page.at('span.css-truncate-target').to_s.strip.gsub(/^<span\sclass="css-truncate-target">/, '').gsub(/<\/span>$/, '')
    source        = pr_inner_page.at('span.commit-ref.head-ref').to_s.strip.gsub(/^<span.*css-truncate-target">/, '').gsub(/<\/span.*>$/, '')
    res           = Blufin::Terminal::execute_proc("Checking #{Blufin::Terminal::format_action(author, false)} / \x1B[38;5;250m#{source}\x1B[38;5;208m against \x1B[38;5;250m#{target}\x1B[38;5;208m", Proc.new {
        validate_merge(source, target)
    })
    if res
        # Blufin::Terminal::success(source)
    else
        Blufin::Terminal::error(Blufin::Terminal::format_invalid(source), nil, false)
    end
end